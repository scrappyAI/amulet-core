use std::collections::HashMap;
use amulet_core::{
    kernel::{Kernel, SystemState, runtime::DefaultRuntime},
    domain::{Command, EncodedCmd, Entity}, // Removed EntityHeader, EncodedState
    access::Capability, // Added Capability for ExpectedSystemState
    types::{AlgSuite, CID, ReplicaID, RightsMask, VectorClock}, // Removed PublicKey, Signature
    error::KernelError,
    events::Event,
    crypto::PlaceholderCryptoProvider, // Removed CryptoProvider
};

// --- TestVectorCommandPayload and its EncodedCmd implementation ---

/// Defines different types of command payloads that can be used in test vectors.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TestVectorCommandPayload {
    /// A raw byte payload. For simplicity, this variant requires no specific rights.
    RawBytes(Vec<u8>),
    // TODO: Add other variants for commands that might interact with rights, specific entity types, etc.
    // e.g., CreateAsset { name: String, symbol: String, supply: u64, issuer_rights: RightsMask },
    // TransferAsset { to_account: CID, amount: u64 },
}

/// Dummy error for the TestVectorCommandPayload's EncodedCmd impl.
#[derive(Debug)]
pub struct TestVectorPayloadError(String);
impl std::fmt::Display for TestVectorPayloadError { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, "{}", self.0) } }
impl std::error::Error for TestVectorPayloadError {}

impl EncodedCmd for TestVectorCommandPayload {
    type Error = TestVectorPayloadError;

    fn encode(&self) -> Vec<u8> {
        match self {
            TestVectorCommandPayload::RawBytes(bytes) => bytes.clone(),
        }
    }

    fn decode(data: &[u8]) -> Result<Self, Self::Error> {
        // For test purposes, we can just assume it's RawBytes if we need to decode.
        // A more robust implementation would require a way to distinguish payload types.
        Ok(TestVectorCommandPayload::RawBytes(data.to_vec()))
    }

    fn required_rights(&self) -> RightsMask {
        match self {
            // For simplicity, RawBytes requires no rights.
            // More complex payloads would specify their required rights here.
            TestVectorCommandPayload::RawBytes(_) => 0, 
        }
    }

    fn to_signed_bytes(&self, id: &CID, alg: AlgSuite, rep: &ReplicaID, cap: &CID, lck: u64) -> Result<Vec<u8>, Self::Error> {
        let mut bytes = Vec::new();
        bytes.extend_from_slice(id);
        bytes.push(alg as u8);
        bytes.extend_from_slice(rep);
        bytes.extend_from_slice(cap);
        bytes.extend_from_slice(&lck.to_le_bytes());
        match self {
            TestVectorCommandPayload::RawBytes(payload_bytes) => bytes.extend_from_slice(payload_bytes),
        }
        Ok(bytes)
    }
}

// --- Core Test Vector Structures ---

/// Represents an input to the kernel during a test case (e.g., a command to apply).
#[derive(Debug, Clone)]
pub struct TestVectorInput {
    // We'll primarily focus on commands for now.
    pub command: Command<TestVectorCommandPayload>,
    // pub incoming_event: Option<Event>, // Could be used for testing process_incoming_event
}

/// Defines the expected state of specific parts of the kernel for verification.
/// Fields are optional to allow checking only relevant parts of the state.
#[derive(Debug, Clone, PartialEq, Eq, Default)]
pub struct ExpectedSystemState {
    pub entities: Option<HashMap<CID, Entity<Vec<u8>>>>,
    pub capabilities: Option<HashMap<CID, Capability>>,
    pub event_log_count: Option<usize>,
    pub local_lc: Option<u64>,
    pub local_vc: Option<VectorClock>, // VectorClock is Option<HashMap<ReplicaID, u64>>
}

/// A summary of key fields of a generated Event for simpler comparison in tests,
/// as the event's CID can be hard to predict deterministically without full crypto.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct PartialEventSummary {
    pub alg_suite: AlgSuite,
    pub replica: ReplicaID,
    pub caused_by: CID, // Command ID
    pub lclock: u64,
    pub num_new_entities: usize,
    pub num_updated_entities: usize,
    pub vector_clock_is_some: Option<bool>, // Check if VC is Some or None, if VCs are enabled for the test
    // We don't include additional_fields here as kernel doesn't generate them on its own events.
}

/// Defines the expected outcome of a test vector: either success with state/event checks, or a specific error.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TestVectorExpectedOutcome {
    Success {
        /// Optional: Summary of the event generated by the last input processing.
        generated_event_summary: Option<PartialEventSummary>,
        /// Expected final state of the kernel after all inputs.
        final_state: ExpectedSystemState,
    },
    Error(KernelError), 
}

/// Represents a single conformance test case.
#[derive(Debug, Clone)]
pub struct ConformanceTestCase {
    pub description: String,
    pub initial_kernel_setup: InitialKernelSetup,
    pub inputs: Vec<TestVectorInput>,
    pub expected_outcome: TestVectorExpectedOutcome,
}

/// Holds the initial setup parameters for a Kernel in a conformance test.
#[derive(Debug, Clone)]
pub struct InitialKernelSetup {
    pub replica_id: ReplicaID,
    pub system_state: SystemState, 
    pub local_lc: u64,
    pub initial_local_vc: Option<HashMap<ReplicaID, u64>>, // CHANGED: Was Option<VectorClock>
    pub enable_vector_clocks: bool,
}

// Placeholder for where test vectors will be defined
pub fn get_conformance_test_vectors() -> Vec<ConformanceTestCase> {
    vec![
        basic_lamport_increment(),
        lamport_command_too_old(),
        lamport_overflow(),
        // TODO: Add more test vectors for:
        // - Rights algebra (sufficient/insufficient)
        // - Capability not found, expiry, alg_suite_mismatch (these are also in proptests but good for conformance)
        // - Event field preservation (requires more setup to simulate incoming event with extra fields)
        // - Hybrid signature rules (once crypto providers are more concrete)
        // - Vector clock specific behaviors (when enabled)
    ]
}

// Placeholder for the test runner function
fn run_conformance_test_case(
    case: &ConformanceTestCase,
    // Using DefaultRuntime and PlaceholderCryptoProvider for now as they are simple
    // and match the current general kernel testing setup.
) {
    println!("  Setting up kernel for: {}", case.description);
    let mut kernel = Kernel::new(
        case.initial_kernel_setup.replica_id,
        DefaultRuntime::default(), // Using DefaultRuntime
        PlaceholderCryptoProvider::default(), // Using PlaceholderCryptoProvider
        case.initial_kernel_setup.enable_vector_clocks,
    );
    kernel.state = case.initial_kernel_setup.system_state.clone();
    kernel.local_lc = case.initial_kernel_setup.local_lc;

    if case.initial_kernel_setup.enable_vector_clocks {
        kernel.local_vc = Some(case.initial_kernel_setup.initial_local_vc.clone().unwrap_or_else(HashMap::new));
    } else {
        kernel.local_vc = None;
        // Ensure consistency: if VCs are disabled, initial_local_vc in setup should ideally also be None or ignored.
        // Forcing it here if a map was provided but VCs are disabled.
        if case.initial_kernel_setup.initial_local_vc.is_some() {
            // This is a bit of a logical inconsistency in test data if it happens.
            // We prioritize enable_vector_clocks = false.
            println!("      Warning: initial_local_vc was Some for a test case where enable_vector_clocks is false. Kernel local_vc forced to None.");
        }
    }

    let mut last_result: Option<Result<Event, KernelError>> = None;

    for (idx, input) in case.inputs.iter().enumerate() {
        println!("    Processing input #{}", idx + 1);
        // For now, we only handle commands in TestVectorInput
        last_result = Some(kernel.apply(&input.command));
        
        // If an intermediate input is expected to fail, and it does, we might short-circuit
        // or the test vector should be structured to only expect final outcome.
        // For now, we proceed and check the outcome of the *last* command primarily.
        if last_result.as_ref().unwrap().is_err() && matches!(case.expected_outcome, TestVectorExpectedOutcome::Success {..}) {
            // If we got an error but expected success, break early for clarity in logs.
            println!("      Input #{} failed unexpectedly: {:?}", idx + 1, last_result.as_ref().unwrap().as_ref().err().unwrap());
            break;
        }
    }

    println!("  Verifying outcome...");
    match (&last_result, &case.expected_outcome) {
        (Some(Ok(actual_event)), TestVectorExpectedOutcome::Success { generated_event_summary, final_state }) => {
            println!("    Expected Success, Got Success.");
            if let Some(expected_summary) = generated_event_summary {
                println!("      Checking event summary...");
                assert_eq!(actual_event.alg_suite, expected_summary.alg_suite, "Event alg_suite mismatch");
                assert_eq!(actual_event.replica, expected_summary.replica, "Event replica mismatch");
                assert_eq!(actual_event.caused_by, expected_summary.caused_by, "Event caused_by mismatch");
                assert_eq!(actual_event.lclock, expected_summary.lclock, "Event lclock mismatch");
                assert_eq!(actual_event.new_entities.len(), expected_summary.num_new_entities, "Event new_entities count mismatch");
                assert_eq!(actual_event.updated_entities.len(), expected_summary.num_updated_entities, "Event updated_entities count mismatch");
                if let Some(expected_vc_is_some) = expected_summary.vector_clock_is_some {
                    assert_eq!(actual_event.vector_clock.is_some(), expected_vc_is_some, "Event vector_clock presence mismatch");
                }
            }

            println!("      Checking final state...");
            if let Some(expected_lc) = final_state.local_lc {
                assert_eq!(kernel.local_lc, expected_lc, "Final local_lc mismatch");
            }
            if let Some(expected_entities) = &final_state.entities {
                assert_eq!(&kernel.state.entities, expected_entities, "Final entities mismatch");
            }
            if let Some(expected_capabilities) = &final_state.capabilities {
                assert_eq!(&kernel.state.capabilities, expected_capabilities, "Final capabilities mismatch");
            }
            if let Some(expected_event_log_count) = final_state.event_log_count {
                assert_eq!(kernel.state.event_log.len(), expected_event_log_count, "Final event_log count mismatch");
            }
            if case.initial_kernel_setup.enable_vector_clocks {
                 if let Some(expected_vc) = &final_state.local_vc {
                    assert_eq!(&kernel.local_vc, expected_vc, "Final local_vc mismatch");
                 }
            } else {
                assert!(kernel.local_vc.is_none(), "Final local_vc should be None when VCs are disabled");
            }

        },
        (Some(Err(actual_error)), TestVectorExpectedOutcome::Error(expected_error)) => {
            println!("    Expected Error, Got Error.");
            // We might need a more nuanced comparison if errors contain dynamic strings.
            // For now, direct comparison of the enum variant might be okay if strings are static or ignored.
            // assert_eq!(actual_error, expected_error, "KernelError mismatch");
            // Using std::mem::discriminant for now to compare enum variants, ignoring contents for InvariantViolation(String) etc.
            assert_eq!(std::mem::discriminant(actual_error), std::mem::discriminant(expected_error), 
                "KernelError variant mismatch. Expected variant of {:?}, Got variant of {:?}", expected_error, actual_error);
            // If we need to check specific string contents for errors like InvariantViolation or Other:
            if let (KernelError::InvariantViolation(act_s), KernelError::InvariantViolation(exp_s)) = (actual_error, expected_error) {
                if !exp_s.is_empty() { // Allow matching any InvariantViolation if expected string is empty
                    assert!(act_s.contains(exp_s), "InvariantViolation message mismatch. Expected contains '{}', Got '{}'", exp_s, act_s);
                }
            }
            if let (KernelError::Other(act_s), KernelError::Other(exp_s)) = (actual_error, expected_error) {
                 if !exp_s.is_empty() {
                    assert!(act_s.contains(exp_s), "Other error message mismatch. Expected contains '{}', Got '{}'", exp_s, act_s);
                 }
            }

        },
        (Some(Ok(_)), TestVectorExpectedOutcome::Error(expected)) => {
            panic!("Test Case Failed: Expected error {:?}, but got Ok(Event)", expected);
        },
        (Some(Err(actual)), TestVectorExpectedOutcome::Success{..}) => {
            panic!("Test Case Failed: Expected success, but got error {:?}", actual);
        },
        (None, _) => {
            panic!("Test Case Failed: No inputs processed, or last_result was not set.");
        }
    }
    println!("    Verification complete for: {}", case.description);
}

#[cfg(test)]
mod tests {
    use super::*;
    // Removed: use amulet_core::kernel::runtime::DefaultRuntime;
    // Removed: use std::collections::HashMap; 

    #[test]
    fn run_all_conformance_vectors() {
        let test_vectors = get_conformance_test_vectors();
        if test_vectors.is_empty() {
            println!("No conformance test vectors defined yet. Skipping run_all_conformance_vectors.");
            return;
        }

        for (i, case) in test_vectors.iter().enumerate() {
            println!("\nRunning conformance test case #{}: {}", i + 1, case.description);
            run_conformance_test_case(
                case
            );
            println!("Successfully completed test case #{}: {}", i + 1, case.description);
        }
    }
}

// Add a modification to InitialKernelSetup to handle local_vc better.
// Change `system_state: SystemState` to `initial_entities` and `initial_capabilities` etc.
// Or add local_vc directly to InitialKernelSetup if it's not part of SystemState itself.
// For now, the runner handles local_vc based on enable_vector_clocks and an assumed optional field in SystemState.
// The SystemState struct itself doesn't have local_vc. Kernel struct does.
// Modifying InitialKernelSetup to be more explicit:
/*
#[derive(Debug, Clone)]
pub struct InitialKernelSetup {
    pub replica_id: ReplicaID,
    pub initial_entities: HashMap<CID, Entity<Vec<u8>>>,
    pub initial_capabilities: HashMap<CID, Capability>,
    pub initial_event_log: Vec<Event>,
    pub local_lc: u64,
    pub local_vc_override: Option<HashMap<ReplicaID, u64>>, // Explicit override for VC state
    pub enable_vector_clocks: bool,
}
*/
// The current runner tries to get local_vc from system_state.local_vc which doesn't exist.
// Correcting the runner for kernel.local_vc initialization:
// It should initialize to Some(HashMap::new()) if enabled and no override, or None if disabled.
// The existing SystemState.local_vc access was a slight misinterpretation.
// The current runner logic for VC init is: if enabled, try from system_state.local_vc (bad path), else Some(new). If disabled, None.
// This is okay if system_state.local_vc is always None (which it would be as it's not a field). So it correctly becomes Some(HashMap::new()) or None.

// --- Test Case Definitions ---

fn generate_test_cid(val: u8) -> CID {[val; 32]}
fn generate_test_replica_id(val: u8) -> ReplicaID {[val; 16]}

fn basic_lamport_increment() -> ConformanceTestCase {
    let replica_id = generate_test_replica_id(1);
    let cap_cid = generate_test_cid(101);
    let cmd_id = generate_test_cid(201);

    let initial_capabilities = {
        let mut caps = HashMap::new();
        caps.insert(cap_cid, Capability {
            id: cap_cid,
            alg_suite: AlgSuite::CLASSIC,
            holder: Vec::new(),
            target_entity: generate_test_cid(0),
            rights: u32::MAX,
            nonce: 0,
            expiry_lc: None,
            signature: Vec::new(),
        });
        caps
    };

    let command = Command {
        id: cmd_id,
        alg_suite: AlgSuite::CLASSIC,
        replica: replica_id,
        capability: cap_cid,
        lclock: 0,
        payload: TestVectorCommandPayload::RawBytes(vec![]),
        signature: Vec::new(),
    };

    ConformanceTestCase {
        description: "Lamport clock increments correctly (max(cmd.lc, kernel.lc+1))".to_string(),
        initial_kernel_setup: InitialKernelSetup {
            replica_id,
            system_state: SystemState {
                capabilities: initial_capabilities.clone(),
                entities: HashMap::new(),
                event_log: Vec::new(),
            },
            local_lc: 0,
            initial_local_vc: None, // Data matches new type Option<HashMap<...>>
            enable_vector_clocks: false,
        },
        inputs: vec![TestVectorInput { command }],
        expected_outcome: TestVectorExpectedOutcome::Success {
            generated_event_summary: Some(PartialEventSummary {
                alg_suite: AlgSuite::CLASSIC,
                replica: replica_id,
                caused_by: cmd_id,
                lclock: 1,
                num_new_entities: 0,
                num_updated_entities: 0,
                vector_clock_is_some: Some(false),
            }),
            final_state: ExpectedSystemState {
                entities: Some(HashMap::new()),
                capabilities: Some(initial_capabilities),
                event_log_count: Some(1),
                local_lc: Some(1),
                local_vc: Some(None), // This now correctly means kernel.local_vc is Option::None
            },
        },
    }
}

fn lamport_command_too_old() -> ConformanceTestCase {
    let replica_id = generate_test_replica_id(2);
    let cap_cid = generate_test_cid(102);
    let cmd_id = generate_test_cid(202);
    let initial_lc = 5u64;

    let initial_capabilities = {
        let mut caps = HashMap::new();
        caps.insert(cap_cid, Capability {
            id: cap_cid,
            alg_suite: AlgSuite::CLASSIC,
            holder: Vec::new(),
            target_entity: generate_test_cid(0),
            rights: u32::MAX,
            nonce: 0,
            expiry_lc: None,
            signature: Vec::new(),
        });
        caps
    };

    let command = Command {
        id: cmd_id,
        alg_suite: AlgSuite::CLASSIC,
        replica: replica_id,
        capability: cap_cid,
        lclock: initial_lc - 2,
        payload: TestVectorCommandPayload::RawBytes(vec![]),
        signature: Vec::new(),
    };

    ConformanceTestCase {
        description: "Command with lclock < kernel.local_lc is rejected".to_string(),
        initial_kernel_setup: InitialKernelSetup {
            replica_id,
            system_state: SystemState {
                capabilities: initial_capabilities.clone(),
                entities: HashMap::new(),
                event_log: Vec::new(),
            },
            local_lc: initial_lc,
            initial_local_vc: None, // Data matches new type
            enable_vector_clocks: false,
        },
        inputs: vec![TestVectorInput { command }],
        expected_outcome: TestVectorExpectedOutcome::Error(KernelError::InvalidCommandLClock),
    }
}

fn lamport_overflow() -> ConformanceTestCase {
    let replica_id = generate_test_replica_id(3);
    let cap_cid = generate_test_cid(103);
    let cmd_id = generate_test_cid(203);

    let initial_capabilities = {
        let mut caps = HashMap::new();
        caps.insert(cap_cid, Capability {
            id: cap_cid,
            alg_suite: AlgSuite::CLASSIC,
            holder: Vec::new(),
            target_entity: generate_test_cid(0),
            rights: u32::MAX,
            nonce: 0,
            expiry_lc: None,
            signature: Vec::new(),
        });
        caps
    };

    let command = Command {
        id: cmd_id,
        alg_suite: AlgSuite::CLASSIC,
        replica: replica_id,
        capability: cap_cid,
        lclock: u64::MAX,
        payload: TestVectorCommandPayload::RawBytes(vec![]),
        signature: Vec::new(),
    };

    ConformanceTestCase {
        description: "Kernel refuses commands if local_lc is u64::MAX (overflow)".to_string(),
        initial_kernel_setup: InitialKernelSetup {
            replica_id,
            system_state: SystemState {
                capabilities: initial_capabilities.clone(),
                entities: HashMap::new(),
                event_log: Vec::new(),
            },
            local_lc: u64::MAX,
            initial_local_vc: None, // Data matches new type
            enable_vector_clocks: false,
        },
        inputs: vec![TestVectorInput { command }],
        expected_outcome: TestVectorExpectedOutcome::Error(
            KernelError::Other("Replica has reached maximum Lamport clock value and cannot process further commands.".into())
        ),
    }
} 